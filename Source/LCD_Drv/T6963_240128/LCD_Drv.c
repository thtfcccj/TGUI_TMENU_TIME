/*******************************************************************************

 			            LCD硬件及TGUI显示接口之t6963驱动实现
 
*******************************************************************************/
#include    "LCD_Drv.h"
#include    "TRowDotBuf.h"
#include    "T6963C_Command.h"
#include    <string.h>

unsigned char Lcd_Drv_TestTimer;  //测试定时器


//-------------------------硬件初始化---------------------------------------
//显示缓冲区的分配:
//LG240128共有32K空间,文本/文本特征区/图形显示缓冲区各需4k空间,CGRAM占2K空间位置定义为:
#define		_GRAPH_RAM_BASE			  0x0000		//0-6K范围为图形显示区
#define		_TEXT_RAM_BASE			  0x1800		//7-10k范围为文本显示
#define		_TEXT_MODE_RAM_BASE		0x2800 		//11-14K范围为文本特征显示区
#define		_CGRAM_BASE			      0x3800 		//15-16K范围为CGRAM区

//形参为是否清屏
unsigned char _FullData = 0;
static void _HwInit(unsigned char EnInitScreen)
{
  //显示区及其大小设置
  T6963_SetTextAddr(_TEXT_RAM_BASE);
  T6963_SetTextWidth(LCD_DEV_WIDTH / 8);
  T6963_SetGraphAddr(_GRAPH_RAM_BASE);
  T6963_SetGraphWidth(LCD_DEV_WIDTH / 8);

  T6963_SetCursor(0,0);//光标
  //其它设置
  T6963_SetDispXorMode(); 	Lcd_cbDelayUs(100);
  T6963_SetCGRAMBaseAddr((unsigned char)(_CGRAM_BASE >> 11));
  T6963_SetCursorShape(0);

  //允许初始化时
  if(EnInitScreen)
  {
    T6963_SetAddr(0);
    T6963_StartAutoWr();
    for (unsigned short i = 0; i < _TEXT_RAM_BASE; i++)
    {
      T6963C_cbWrData(_FullData);
    }
    T6963_AutoEnd();
  }
  T6963C_SetDispSwitch(T6963C_GRAPH_EN);//打开相关显示	
}

//-------------------------模块初始化---------------------------------------
void Lcd_Drv_Init(void)	
{
  _HwInit(1);        //硬件初始化
  TRowDotBuf_Init();//缓冲初始化
  //LCD模块软件初始化


}

//-------------------------测试任务函数---------------------------------------
//任务函数,0.5s一次
#ifdef SUPPORT_LCD_TEST
unsigned char Lcd_Drv_TestTimer = 0;  //测试定时器
void Lcd_Drv_TestTask(void)
{
  if(!Lcd_Drv_TestTimer) return;
  Lcd_Drv_TestTimer--;
  if(!Lcd_Drv_TestTimer){
    Lcd_Drv_cbTestFinalNotify();//通报测试完成
  }
  unsigned char *pDotBuf = TRowDotBuf_pGetDispBuf();  
  
  if(Lcd_Drv_TestTimer > LCD_DEV_TEST_FULL){//满屏测试
    memset(pDotBuf, 0xff, (LCD_DEV_WIDTH / 8) * 2 * 8);
  }
  else if(Lcd_Drv_TestTimer > LCD_DEV_TEST_NULL){//空屏测试
    memset(pDotBuf, 0, (LCD_DEV_WIDTH / 8) * 2 * 8);
  }
  else if(Lcd_Drv_TestTimer > LCD_DEV_TEST_REFRESH){//刷屏测试
    memset(pDotBuf, 1 << (Lcd_Drv_TestTimer - LCD_DEV_TEST_REFRESH), 
           (LCD_DEV_WIDTH / 8) * 2 * 8);
  }
  else{//停止刷屏
    return;
  }
  //送显
  for(unsigned char y = 0; y < LCD_DEV_HIGH / 8; y++){ //行数
    unsigned short CurAdr = y * 16 * (LCD_DEV_WIDTH / 8);//当前行起始地址
    for(unsigned char i = 0; i < 16; i++){
    T6963_SetAddr(CurAdr);
    T6963_StartAutoWr();
      T6963C_SqureWrData(pDotBuf + i * LCD_DEV_WIDTH / 8, 
                         LCD_DEV_WIDTH / 8);//写当前行数据
      T6963_AutoEnd();
      CurAdr += (LCD_DEV_WIDTH / 8);//下一行起始地址
    } //end for i
  }// end for y
}
#endif


/****************************************************************************

							TGUI显示屏回调函数实现
//注:此模块暂不支持DISP_CMD_DIS_UPDATE命令,若有,当做清屏处理																
****************************************************************************/
#include "TGUIBase.h"

//应用直接相关：
#include "SRA.h"
#include "SRR.h"
#include "GUI_Top.h"
#include "GUI_Guide.h"
#include "RecMenu.h"
//-------------------------显示屏更新一行内容函数--------------------
void TWinMng_cbUpdateRow(unsigned char Lcd,    //当前操作那个显示屏
                         unsigned char x,      //需要更新的行起始位置
                         unsigned char y,      //需要更新的行
                         unsigned char w,      //更新长度
                         const char *pBuf,    //需更新字符
                         //每个字符对应位置标志,见下列定义
                         const unsigned char *pFlagBuf)
{
  unsigned char i;
  const unsigned char *pDotBuf;
  unsigned short CurAdr;

  #ifdef SUPPORT_LCD_TEST
  if(Lcd_Drv_TestTimer) return; //测试期间禁止刷屏
  #endif
  
  //若需支持DISP_CMD_DIS_UPDATE时,需在此进行分块处理!!!
  //应用相关：最下一行下划线暂时直接做到底层
  if(y == 7){
    for(i = 0; i < w; i++){
      *((unsigned char*)(pFlagBuf + i)) = DISP_CMD_NOR | DISP_CFG_UP_LINE;
    }
  }
  //应用相关：最顶行必要时替换字符串
  if(y == 0){
    const char *pTopBuf = GUI_Top_pGetBuf();
    if(pTopBuf != NULL){//行替换时
      memcpy((char*)pBuf, pTopBuf, TLCD_WIDTH + 1);
      for(i = 0; i < w; i++){//显示下横线
        *((unsigned char*)(pFlagBuf + i)) = DISP_CMD_NOR | DISP_CFG_DOWN_LINE;
      }
    }
  }
  //先取出整块字模
  pDotBuf = TRowDotBuf_pGetBuf(w,pBuf,pFlagBuf);
  //应用相关：倒数第二行上划虚线
  if(y == 6){
    if(TWin_IsHidden(TMenu_pGetTWin(TM_hGetMenuWin())) && //菜单没显示时才有虚线
       (GUI_Guide_eGetGuide() != eGUI_Guide_User) && 
       (GUI_Guide_eGetGuide() != eGUI_Guide_Menu) && 
        (GUI_Guide_eGetGuide() != eGUI_Guide_Test) &&  
          !((GUI_Guide_eGetGuide() == eGUI_Guide_Rec) && (RecMenu.RecType == 0xff))){
      for(i = 0; i < 30; i++)
      *((unsigned char *)pDotBuf + i) = 0xaa;
    }
  }  
  //应用相关：最下一行下划线最左侧虚线表示报警抑制，右侧虚线表示故障抑制
  if(y == 7){
    if(SRA_IsRestrain()) *((unsigned char *)pDotBuf) = 0xaf;
    if(SRR_IsRestrain()) *((unsigned char *)pDotBuf + 29) = 0xf5;    
  }
  //将字模按行送出,仅更新显示屏宽度大小
  CurAdr = y * 16 * (LCD_DEV_WIDTH / 8) + x;//当前行起始地址
  for(i = 0; i < 16; i++){
	T6963_SetAddr(CurAdr);
	T6963_StartAutoWr();
    T6963C_SqureWrData(pDotBuf + i * w, LCD_DEV_WIDTH / 8);//写当前行数据
    T6963_AutoEnd();
    CurAdr += (LCD_DEV_WIDTH / 8);//下一行起始地址
  }
}


/****************************************************************************
                          TRowDotBuf回调函数实现
****************************************************************************/
#include "at45drv.h"
#include "at45io.h"

//------------------得到GB2312点阵位置函数-------------------------------
__arm __inline U32 GetGB2312Pos(U16 c)
{
        U32 c0 = (c & 0xff) - 0xa1;   //低偏移
        U32 c1 = (c >> 8) - 0xa1;   //高位偏移
        return c1 * 94 + c0;
}

static const unsigned char _UserWordModuleBuf[] = {//定制全角字符
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x5D,0x06,0xD5,0x05,0x55,//a0a0
  0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0xB5,0x5D,0x00,0x00,0x00,0x00,// umol
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x5D,0x16,0xD5,0x15,0x55,//a0a1
  0x25,0x55,0x25,0x55,0x25,0x55,0x45,0x55,0x45,0x55,0x45,0x5D,0x00,0x00,0x00,0x00,// mol
  0x00,0x00,0x00,0x00,0x08,0x00,0x08,0x1C,0x10,0x04,0x10,0x1C,0x16,0xC4,0x25,0x5C,//a0a2
  0x25,0x40,0x25,0x40,0x45,0x40,0x45,0x40,0x45,0x40,0x00,0x00,0x00,0x00,0x00,0x00,// /m3
  0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x00,0x20,0x20,0x20,0x00,0x4D,0xAE,//a0a3
  0x4A,0xAA,0x4A,0xAA,0x8A,0xAA,0x8A,0xAA,0x8A,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,// /min 
  0x00,0x00,0x00,0x00,0x00,0x04,0x01,0xC4,0x00,0x44,0x01,0xC8,0x6C,0x48,0x55,0xC8,//a0a4
  0x54,0x10,0x54,0x10,0x54,0x10,0x54,0x20,0x54,0x20,0x00,0x20,0x00,0x00,0x00,0x00,// /m3/ 
  0xFD,0xFF,0xFE,0xFF,0x00,0x01,0xFF,0xFF,0xF0,0x1F,0xF7,0xDF,0xF0,0x1F,0xFF,0xFF,//a0a5
  0x80,0x03,0xBF,0xFB,0xB0,0x1B,0xB7,0xDB,0xB7,0xDB,0xB0,0x1B,0xBF,0xEB,0xBF,0xF7,// 高（取反） 
  0xF7,0xE7,0xF3,0x83,0xE4,0x5F,0xED,0xDF,0xDD,0xDF,0x9D,0xDF,0x5C,0x01,0xDD,0xDF,//a0a6
  0xDD,0xDF,0xDD,0xDF,0xDD,0xEF,0xDD,0xAD,0xDD,0x75,0xDC,0xB9,0xDD,0xDD,0xFF,0xFF,// 低（取反） 
  0xEE,0x03,0xEE,0xFB,0xEE,0xFB,0x02,0xEB,0xEE,0xF7,0xEA,0xFF,0xE6,0x03,0xCE,0x7B,//a0a7
  0x2E,0xB7,0xEE,0xB7,0xEE,0xCF,0xEE,0xEF,0xEE,0xC7,0xEE,0xB1,0xAE,0x7B,0xDE,0xFF,// 报（取反） 
  0xEB,0xBF,0x80,0xBF,0xEB,0x81,0x80,0xB7,0x9E,0x57,0x42,0xEF,0xDA,0xD7,0xC2,0xBB,//a0a8
  0xFD,0x7D,0x00,0x01,0xFF,0xFF,0xE0,0x0F,0xFF,0xFF,0xE0,0x0F,0xEF,0xEF,0xE0,0x0F,// 警（取反）
  0x04,0x04,0x04,0x02,0x04,0x02,0x7F,0xC0,0x44,0x48,0x44,0x45,0x7F,0xC1,0x44,0x41,//a0a9
  0x44,0x42,0x44,0x42,0x7F,0xCC,0x44,0x44,0x04,0x15,0x04,0x15,0x03,0xF6,0x00,0x04,//电源
  0x00,0x20,0xFF,0x3E,0x88,0x28,0x90,0x45,0xBE,0x08,0xA2,0x08,0xBE,0x08,0xA2,0x7E,//a0aa
  0xBE,0x18,0x88,0x1C,0xAA,0x2A,0xA9,0x2A,0x29,0x48,0x49,0x08,0x09,0x08,0x10,0x08,//箱
  0x80,0x82,0xF8,0x83,0xA0,0x82,0x10,0x82,0x07,0xF7,0xF0,0x84,0x90,0x84,0x93,0xEC,//a0ab
  0xF2,0x32,0x92,0x22,0x92,0x21,0xF2,0x21,0x93,0xE2,0x92,0x0C,0xF0,0x30,0x90,0x00,//故
  0x00,0x10,0x0F,0x7C,0x09,0x28,0x0A,0x28,0xFA,0xFE,0x4C,0x00,0x4A,0x7C,0x49,0x44,//a0ac
  0x89,0x7C,0x8D,0x44,0x0A,0x7C,0x08,0x10,0x88,0xFE,0x78,0x10,0x28,0x10,0x08,0x10,//障
//  0x04,0x04,0x04,0x02,0x04,0x02,0x7F,0xC0,0x44,0x48,0x44,0x45,0x7F,0xC1,0x44,0x41,//a0ad
//  0x44,0x42,0x44,0x42,0x7F,0xCC,0x44,0x44,0x04,0x15,0x04,0x15,0x03,0xF6,0x00,0x04,//电源
//  0x00,0x20,0xFF,0x3E,0x88,0x28,0x90,0x45,0xBE,0x08,0xA2,0x08,0xBE,0x08,0xA2,0x7E,//a0ae
//  0xBE,0x18,0x88,0x1C,0xAA,0x2A,0xA9,0x2A,0x29,0x48,0x49,0x08,0x09,0x08,0x10,0x08,//箱
  0x81,0xFF,0xF9,0x11,0xA1,0x11,0x11,0xFF,0x01,0x11,0xF1,0x11,0x91,0xFF,0x90,0x18,//a0ad
  0xF0,0x24,0x90,0x43,0x91,0xA4,0xF6,0x24,0x90,0x24,0x90,0x44,0xF0,0x84,0x91,0x04,//界
  0x00,0x00,0x1F,0xFF,0x00,0x80,0x01,0x00,0x0F,0xFE,0x09,0x12,0x09,0x12,0x09,0xF2,//a0ae
  0x09,0x12,0x09,0x12,0xE9,0xF2,0x49,0x12,0x09,0x12,0x0F,0xFE,0x08,0x02,0x00,0x00,//面
  0xDF,0x7F,0xDF,0x03,0xDF,0x77,0x56,0x77,0x55,0xAF,0x53,0xDF,0x57,0x23,0x54,0xB7,//a0af
  0x57,0xBF,0x54,0x03,0x47,0xBF,0x14,0x03,0x7F,0xBF,0xF8,0x01,0xFF,0xBF,0xFF,0xBF,//峰
  0xEF,0xBF,0xE7,0x9F,0xE8,0x03,0xEF,0xBF,0xDF,0x7F,0xCC,0x07,0x9D,0xF7,0x5C,0x07,//a0b0
  0xDD,0xF7,0xDC,0x07,0xDD,0xF7,0xDC,0x07,0xDD,0xF7,0xDD,0xF7,0xD0,0x01,0xDF,0xFF,//值
  0xEF,0xFF,0xF7,0xF1,0x80,0x8F,0xDD,0xBF,0xEB,0xBF,0x00,0x81,0xF7,0xB7,0xF7,0xB7,//a0b1
  0x00,0xB7,0xF7,0xB7,0xD3,0xB7,0xD5,0x77,0xB5,0x77,0x76,0xF7,0xD5,0xF7,0xEF,0xF7,//新
  0xC0,0x03,0xDF,0xFB,0xDF,0xFB,0xC0,0x03,0xDB,0xEF,0xDD,0xDF,0xD0,0x03,0xDD,0xDF,//a0b2
  0xDD,0xDF,0xC0,0x01,0xDD,0xDF,0xDD,0xDF,0xBB,0xDF,0xBB,0xDF,0x77,0xDF,0xEF,0xDF,//屏
  0xFB,0xBF,0x00,0x01,0xFB,0xBF,0xF7,0x9F,0xB6,0xCF,0xD5,0xDF,0x80,0x81,0xB6,0xBB,//a0b3
  0xA2,0x3B,0xA4,0xD7,0x94,0xD7,0x96,0xEF,0xB6,0xEF,0xB2,0xD7,0xB5,0xB9,0xFF,0x7B,//蔽
};

//-----------------------得到全角字字模--------------------------
__arm void TRowDotBuf_cbGetWordModule(unsigned char *pBuf, //接收缓冲区
                                unsigned short c)   //字码
{
  if((c <= 0xa0fe)/* && (c >= 0xa0a0)*/){//定制的全角字符范围
    memcpy(pBuf, &_UserWordModuleBuf[(c - 0xa0a0) * 32], 32);
    return;
  }
  
  unsigned char i;
  unsigned long adr;

  //得到地址，不知为什么好像字库生成器错开了一格
  adr =  GetGB2312Pos(c) * 32 + (AT45A_16X16GB_SONG_BASE - 1);
  AT45_Read(&At45a,pBuf,32,adr); //读取点阵数据到缓冲区
  for(i = 0 ; i < 8; i++){
   if(*(pBuf + i) != 0) return;   //非0时认为读取正确
  }
  AT45_Read(&At45a,pBuf,32,adr); //全部为0时再次读取点阵数据到缓冲区
}

static const unsigned char _NumBuf[] = {//数字区相关缓冲,用于加快速度,从33开始至63
0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
0x00, 0x14, 0x28, 0x28, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x14, 0x14, 0x7e, 0x14, 0x14, 0x28, 0x7e, 0x28, 0x28, 0x28, 0x00, 0x00, 0x00,
0x00, 0x00, 0x10, 0x38, 0x54, 0x54, 0x50, 0x30, 0x18, 0x14, 0x54, 0x54, 0x38, 0x10, 0x10, 0x00,
0x00, 0x00, 0x00, 0x44, 0xa4, 0xa8, 0xa8, 0x50, 0x14, 0x2a, 0x2a, 0x4a, 0x44, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x20, 0x50, 0x50, 0x50, 0x7c, 0xa8, 0xa8, 0x98, 0x88, 0x76, 0x00, 0x00, 0x00,
0x00, 0x60, 0x60, 0x20, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x02, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x04, 0x02, 0x00, 0x00,
0x00, 0x40, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x08, 0x08, 0x10, 0x10, 0x20, 0x40, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0xd6, 0x38, 0x38, 0xd6, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0xfe, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x20, 0xc0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x00, 0x00, 0x00,
0x00, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x00, 0x00,
0x00, 0x00, 0x00, 0x18, 0x24, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x10, 0x70, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7c, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x02, 0x04, 0x08, 0x10, 0x20, 0x42, 0x7e, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x04, 0x18, 0x04, 0x02, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x08, 0x08, 0x18, 0x28, 0x48, 0x48, 0x7e, 0x08, 0x08, 0x1e, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x7e, 0x40, 0x40, 0x5c, 0x62, 0x02, 0x02, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x1c, 0x24, 0x40, 0x40, 0x5c, 0x62, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x7e, 0x44, 0x44, 0x08, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x24, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x38, 0x44, 0x42, 0x42, 0x46, 0x3a, 0x02, 0x02, 0x24, 0x38, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00,
0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00,
0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x02, 0x04, 0x08, 0x08, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
};

//-----------------------得到半角字字模--------------------------
__arm void TRowDotBuf_cbGetHalfWordModule(unsigned char *pBuf, //接收缓冲区
                                    unsigned char c)    //字码
{
  if(c <= 32) //前33个字符为控制码,且干扰空易丢失,直接填充空格(含空格)
    memset(pBuf, 0, 16);
  else if(c < 64)//数据区直接使用用于加快速度
    memcpy(pBuf, &_NumBuf[(c - 33) * 16], 16);
  else
    AT45_Read(&At45a,pBuf,16,AT45A_8X16ASC_BASE + c * 16);
}




